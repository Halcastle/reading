# JAVA多线程

> 为什么会有多线程？
>
> 多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务。
>
> 本质原因是摩尔定律失效，CPU进入多核时代。加上互联网时代的来临，分布式系统开发大规模普及。

## JAVA线程的创建过程

JAVA语言中创建线程本质上只有一种方式：`new Thread()` ，启动线程则是调用`start()`方法；

Thead#Strart()：启动一个新线程并异步执行其中的任务（真正创建了一个物理线程）；

Thread#run()：在当前的主线程执行，和调用其他对象的普通方法没区别；

> JAVA中，继承Thread类，实现Runable接口，实现Callable接口，这些方式创建的都是可执行任务，并没有真正的创建线程。

![image-20210622161006863](C:\Users\pwang6\AppData\Roaming\Typora\typora-user-images\image-20210622161006863.png)

## 进程与线程的区别

一般来说，进程中可以包含多个线程，这些线程共享一块内存地址空间，Linux系统中，线程和进程概念没有严格区分。

1. 线程被称为轻量级的进程；
2. 线程之间的切换开销更小；
3. 线程占用的资源比进程少；
4. 进程之间是独立的，不能共享内存地址空间

## 守护线程

守护线程（Daemon Thread）也叫后台线程。

在JVM中，如果没有正在运行中的前台线程，则JVM就会自动结束运行，而不管守护线程。所以守护线程一般用于执行某些可以被放弃的任务或事件。

> java中典型的守护线程：GC
>
> 如何设置守护线程：Thread.setDaemon(true)，Daemon属性需要在启动线程之前设置，不能在启动后设置。
>
> Java虚拟机退出时Daemon线程中的finally块不一定会执行

## Thread的启动方式

调用t.start()方法

## Runnable-基础接口

> Thread类继承了Runnable接口，创建线程对象时，可以传入需要执行的Runnable任务

Runnable#run() 没有返回值

Callable#call()有返回值

## 线程的状态

- NEW：初始状态，尚未启动
- RUNNABLE：可运行状态
- RUNNING：运行中
- READY：就绪状态
- WAITING：等待状态
- TIME_WAITING：限时等待被唤醒的状态
- BLOCKED：阻塞状态，被对象锁或者IO阻塞
- TERMINATED：终止状态

![image-20210622164036572](C:\Users\pwang6\AppData\Roaming\Typora\typora-user-images\image-20210622164036572.png)

# 线程安全

> 保证多个线程并发执行同一段代码时，不会出现不确定的结果，也不会出现与单线程执行时不一致的结果，也就是保证多个线程对共享状态操作的正确性。
>
> 在JAVA 中，完全由代码来控制线程安全，共享状态一般是指堆内存中的数据（对象的属性）

## 并发相关的性质

- 原子性：对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。两个**原子性的操作，先后执行，不能保证整体原子性。**
- 可见性：一个线程执行的修改操作，对其他线程来说必须立即可见。JAVA提供了volatile关键字来保证可见性，读取时强制从主内存读取。**可见性不能解决原子性。**
- 有序性：保证线程内的串行语义，避免指令重排，例如增加内存屏障。

## synchronized

> Synchronized原理：Java中的每个对象都是对象锁（Object monitor），主要适用对象头标记字来实现。
>
> Synchronized保证了方法和代码块中的操作是原子性的（执行时只有一个线程访问到）、可见的（在解锁之前会将变量同步回主存中）、有序性（单线程是有序执行的）

## synchronized使用的锁

- 实例方法锁的是this代表的对象；
- 静态方法锁的是对应的class对象；
- synchronized块使用的是this对象；
- synchronized(obj)使用的是obj对象；

## synchronized的优化

> 可参考：https://www.cnblogs.com/xudilei/p/6840061.html

1. synchronized方法的优化：自jdk1.6之后，根据不同情形出现了偏向锁、轻量锁、对象锁、自旋锁（或自适应自旋锁），现在的synchronized为一个几种锁过程的封装；
2. 偏向锁：BiaseLock，轻量锁，其开销相当于没有锁

## volatile

> 1. 每次读取都强制从主内存刷数据；
> 2. 适用场景：单个线程写；多个线程读；
> 3. 原则：能不用就不用，不确定的时候也不用；
> 4. 替代方案：Atomic原子操作类